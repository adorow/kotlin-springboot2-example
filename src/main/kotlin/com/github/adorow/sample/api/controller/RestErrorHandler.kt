package com.github.adorow.sample.api.controller

import org.springframework.boot.web.servlet.error.DefaultErrorAttributes
import org.springframework.boot.web.servlet.error.ErrorAttributes
import org.springframework.context.annotation.Bean
import org.springframework.http.HttpStatus
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.ResponseStatus
import org.springframework.web.context.request.WebRequest
import java.io.IOException
import javax.servlet.http.HttpServletResponse

@ControllerAdvice
class RestErrorHandler {

    // Overrides the error attributes generated automatically by Spring (for "Bad Request" based on wrong input types for example)
    @Bean
    fun errorAttributes(): ErrorAttributes =
            object : DefaultErrorAttributes() {

                override fun getErrorAttributes(webRequest: WebRequest, includeStackTrace: Boolean): Map<String, Any> {
                    val errorAttributes = super.getErrorAttributes(webRequest, includeStackTrace)

                    // hides some metadata from the user
                    return errorAttributes.apply {
                        remove("exception")
                        remove("path")
                        remove("timestamp")
                    }
                }

            }


    @ExceptionHandler(NotFoundException::class) // tells Spring the exception that should be handled/transformed
    @ResponseStatus(HttpStatus.NOT_FOUND)// tells Spring what status to return (when the function's return type is a class, i.e. the payload) - so here it actually has no effect, since we use "HttpServletResponse.sendResponse"
    @Throws(IOException::class) // tells the Kotlin compiler to add this 'throws' instruction to the generated bytecode (for Java compatibility basically)
    fun handleNotFound(response: HttpServletResponse): Unit =
            response.sendError(HttpStatus.NOT_FOUND.value())

}